
# 인덱스

1. 이해 가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드다.  
2. 객체 사이의 의존성을 완전히 없애는 것이 정답은 아니다. 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이다. 따라서 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거해야 한다.
3. 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.
4. 객체지향의 세계에서는 무생물 역시 스스로 행동하고 자기 자신을 책임지는 자율적인 존재로 취급해야 한다. 이를 의인화라고 부른다.
5. 객체의 경계 명확성이 객체의 자율성을 보장하기에, 내부와 외부를 확실하게 구분해야 한다.
6. 컴파일 시점 의존성과 런타임 의존성은 서로 다를수록 코드는 더 유연해지고 확장 가능해진다. 하지만 코드를 이해하기 어려워진다는 사실은 명심해야 한다.
7. 인터페이스 재사용할 목적이 아니라 구현을 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드를 낳게 될 확률이 높다.
8. 컨텍스트 독립성
9. 겍체지향의 본질은 협력하는 객체들의 공동체를 창조하는 것이며, 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정이 핵심이다.
10. 객체의 인터페이스는 무엇을 하는지는 포현해야 하지만 어떻게 수행하는 지를 노출해서는 안된다.

# 오브젝트

[종립님의 오브젝트 스터디 레포](https://github.com/johngrib/study-objects)를 가이드 삼아 테스트 코드 까지 학습한다.  

# 1장. 티켓 판매

- `Invitation` : 이벤트 당첨자에게 발송되는 초대장이며 티켓으로 교환할 수 있다.
  - 초대일자를 인스턴스 변수로 포함하는 간단한 클래스
- `Ticket`
- `Bag` : 관람객은 소지품을 보관할 용도로 가방을 항상 소지하고 있다고 가정한다. 
- `Audience` : 관람객을 의미하며, 가방을 소지한다.
- `TicketOffice` : 관람객에게 판매할 티켓과 티켓의 판매 금액이 보관되어 있으며, 초대장을 티켓으로 교환해주는 매표소이다.
  - 티켓의 목록과 판매 금액을 변수로 포함한다.
- `TicketSeller` : 판매원은 자신이 일하는 매표소에 의존하며, 티켓으로 교환해주거나 판매하는 역할을 수행한다.
- `Theater` : 관람객을 맞이하는 소극장이다.

`Theater.enter()`는 너무 많은 책임을 가지고 있다.  
소극장이 관람객의 가방을 뒤져 초대권을 확인하고 존재하면 티켓을 가방에 넣어주고, 없으면 가방에서 돈을 뺏어서 티켓을 넣어준다.  
그리고 이 티켓을 가져오는 행위도 판매원에게 묻지않고 매표소를 직접 가져와서 묻는다.  
즉, **관람객과 판매원이 소극장의 통제를 받는 수동적인 존재이기 때문에 이 입장(enter)이라는 행위를 이해하기 위해 관람객의 가방, 가방안에 있는 현금과 티켓, 초대권 그리고 판매원의 매표소까지 너무 많은 정보가 노출되어 있다는 점이다.**  
**그리하여 관람객과 판매원이 수정되면 소극장까지 영향을 받을 수 밖에 없다.**   
  
## 리팩토링하기

1. 판매원은 매표소를 노출하지 않도록 하고, 판매원이 매표소에서 티켓을 전달하며 관람객이 직접 초대권의 유무를 확인하고 티켓의 가격만큼 금액을 제출한다. [예제](https://github.com/jdalma/object/commit/f2eeafb9d98a04970109244d612757dd1018059c)
2. 관람객이 가방을 직접 뒤지지 않고 가방에게 초대권의 유무를 물어보고 티켓의 가격만큼 금액을 차감하도록 한다. [예제](https://github.com/jdalma/object/commit/b00e53a7d13f17ee2c6440dd1665bfc3e5f569f6)
3. 판매원이 매표소를 까서 직접 티켓을 가져오고 돈통에 돈을 넣기에 현재 매표소는 수동적인 클래스다. 
   1. [ ] 매표소에 관람객을 전달해서 의존성은 추가되지만 능동적인 클래스로 만드는 것이 좋을까?
   2. [x] 매표소가 관람객에 대한 의존성이 추가되진 않지만 판매원에게 제어되는 수동적인 클래스로 만드는 것이 좋을까? 

## 궁금한 점

1. TicketSeller와 TicketOffice의 의존 방향이 반대로 되어야 하지 않나? 판매원이 매표소를 알 것이 아니라 매표소가 판매원을 알아야하지 않나? 그냥 돈통이라는 의미인가?
2. 의인화를 통해 TicketSeller의 책임을 TicketOffice에 모두 전가하는 것은 어떤가? 그럼 TicketSeller는 제거될 수 있지 않나?

## 핵심

소극장에게 몰려있던 책임을 판매원과 관람객에게 책임을 분할하면서 캡슐화를 하였다.  
더 나아가 관람객에게 의존하던 가방에게도 책임을 나누어줬다.  
이때, 판매원에게 의존하던 매표소에게도 책임을 나누어주려 하였지만 매표소가 티켓을 전달하고 돈통에 돈을 증가시키는 책임을 가지게 하려면 관람객에 대한 불필요한 의존성이 추가되어 매표소는 그대로 두었다.  

# 2장. 영화 상영

## 영화 예매 시스템

'영화'는 영화에 대한 제목, 상영시간, 가격 정보와 같이 영화가 가지고 있는 기본적인 정보를 가리킨다.    
'상영'은 상영 일자, 시간, 순번 등을 가리키며 실제로 관객들이 영화를 관람하는 사건을 표현한다.  
영화는 하루 중 다양하 시간대에 걸쳐 한 번 이상 상영될 수 있다.  
그렇기에 소비자는 영화를 구매하는 것이 아니라 특정 시간에 상영되는 영화를 관람할 수 있는 권리를 구매하기 위해 돈을 지불한다.  
  
특정한 조건을 만족하면 요금을 할인받을 수 있다.  
- **할인 조건** : 가격의 할인 여부를 결정하며, `순서 조건`과 `기간 조건`의 두 종류로 나뉜다.
  - 순서 조건은 예를 들어, 매일 10번째로 상영되는 영화를 예매한 사용자들에게 할인 혜택을 제공하는 것
  - 기간 조건은 요일, 시작 시간, 종료 시간의 세 부분으로 구성되며 영화 시작 시간이 해당 기간안에 포함될 경우 요금을 할인한다.
    - 예를 들어, 매주 월요일 오전 10시부터 오후 1시 사이에 상영되는 모든 영화에 대해 할인 혜택을 적용할 수 있다.
- **할인 정책** : 할인 요금을 결정하며, `금액 할인 정책`과 `비율 할인 정책`이 있다.
  - 금액 할인 정책은 예매 요금에서 일정 금액을 할인해준다.
  - 비율 할인 정책은 정가에서 일정 비율의 요금을 할인해주는 방식이다.

영화별로 하나의 할인 정책만 할당할 수 있으며, 할인 조건은 순서 조건과 기간 조건을 여러 개 섞는 것도 가능하다.  
할인을 적용하기 위해서는 할인 조건과 할인 정책을 함께 조합해서 사용한다.  

1. 사용자의 예매 정보가 할인 조건 중 하나라도 만족하는지 검사한다.
2. 할인 조건을 만족할 경우 할인 정책을 이용해 할인 요금을 계산한다.
3. 할인 정책은 적용돼 있지만 할인 조건을 만족하지 못하는 경우나 아예 할인 정책이 적용돼 있지 않은 경우에는 요금을 할인하지 않는다.

## 구현하기

- 영화 : `Movie`
- 상영 : `Screening`
- 할인정책 : `DiscountPolicy`
  - 금액할인정책 : `AmountDiscountPolicy`
  - 비율할인정책 : `PercentDiscountPolicy`
- 할인조건 : `DiscountCondition`
  - 순번조건 : `SequenceCondition`
  - 기간조건 : `PeriodCondition`
- 예매 : `Reservation`

상영이 `reserve(customer, audienceCount)`를 통해 예약을 생성한다. 예약 금액을 구할 때는 영화에게 영화 금액을 요청한다.  
할인정책은 여러 개의 할인조건을 주입받아 할인조건에 부합하는 상영인지 확인하고 부합한다면 자신을 상속한 자식에게 할인금액을 계산하도록 메시지를 전송한다.  

## 핵심

추상 클래스와 인터페이스, 상속과 합성에 대한 트레이드 오프를 고민하는 것이 이번 장의 핵심이다.   

![](./imgs/policyAndCondition.png)

할인정책은 추상 클래스를 사용하여 템플릿 메소드 패턴으로 자식 클래스들을 추가할 수 있었지만, NonDiscountPolicy가 추가되면서 DiscountPolicy는 인터페이스로 변경하고 DefaultDiscountPolicy를 추상클래스로 추가하였다.

# 3장. 협력, 역할, 책임

> 협력이 책임을 이끌어내고 책임이 협력에 참여할 객체를 결정한다.  
> 메시지는 외부의 객체가 요청하는 무언가를 의미하기 때문에 메시지를 먼저 식별하면 무엇을 수행할지에 초점을 맞추는 인터페이스를 얻을 수 있다.  
> 협력 → 책임 → 메시지 → 역할 → 객체 → 클래스(행동) → 클래스(상태)

많이 하는 실수가 객체의 행동이 아니라 상태에 초점을 맞추어 상태를 먼저 결정하고, 그 후에 상태에 필요한 행동을 결정하는 것이다.  
이런 방식은 객체의 내부 구현이 공개 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해하며 변경의 여파가 해당 객체의 의존하는 클라이언트까지 퍼지게 된다.  
  
**최대한 구현에 대한 결정을 뒤로 미루면서 객체의 행위를 고려하기 위해서는 항상 협력이라는 문맥 안에서 객체를 생각해야 한다.**  

## 협력이란?

협력은 객체를 설계하기 위한 구체적인 문맥을 제공한다.  
어떤 요청을 해결하기 위해 두 개 이상의 객체가 상호작용을 통해 더 큰 책임을 수행하는 것이다.  
이 협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 설계자가 생각하는 문제 해결 컨텍스트 내에서 협력하는 파트너라고 인식해야 한다.  
  
객체란 상태와 행동을 함께 캡슐화하는 실행 단위다.  
그렇다면 객체가 가질 수 있는 상태와 행동을 어떤 기준으로 결정해야 할까?  
객체를 설게할 때 어떤 행동과 상태를 할당했다면 그 이유는 무엇인가?  
  
객체가 존재하는 이유는 협력에 필요한 적절한 행동을 보유하고 동시에 어떤 협력에 참여하고 있기 때문이다.  
**결론적으로 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다.**  
객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다.  
  
> 상태는 객체가 행동하는 데 필요한 정보에 의해 결정되고 행동은 협력 안에서 객체가 처리할 메시지로 결정된다.  
> 결과적으로 객체가 참여하는 협력이 객체를 구성하는 행동과 상태를 모두 결정한다.  
> **따라서 협력은 객체를 설계하는 데 필요한 일종의 `문맥`을 제공한다.**

## 책임이란?

객체를 설계하기 위한 문맥인 협력이 갖춰졌다면 협력에 필요한 행동을 수행할 수 있는 적절한 객체를 찾는 것이다.  
객체의 책임은 객체가 `무엇을 할 수 있는가?`와 `무엇을 알고 있는가?`로 구성된다.  

- **하는 것**
  - 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것
  - 다른 객체의 행동을 시작시키는 것
  - 다른 객체의 활동을 제어하고 조절하는 것
- **아는 것**
  - 사적인 정보에 관해 아는 것
  - 관련된 객체에 관해 아는 것
  - 자신이 유도하거나 개선할 수 있는 것에 관해 아는 것

이때까지의 예로 설명해보자.

1. Screening이 reserve 메시지를 수신하고 movie를 인스턴스 변수로 포함하는 이유는 협력 안에서 영화를 예매할 책임을 수행해야 하기 때문이다.
2. Movie가 calculateMovieFee 메시지를 수신할 수 있고 fee와 discountPolicy를 속성으로 가지는 이유는 협력 안에서 가격을 계산할 책임을 할당받았기 때문이다.

> 객체지향 설계에서 가장 중요한 것은 `책임`이다.

# 역할이란?

객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 역할이라고 부른다.  
이전에 보았던 영화를 *예매하라* 라는 메시지를 처리하는 객체를 고민할 때 Screening을 선택한 것이 **역할에 대한 결정을 먼저하고 객체를 선택하는 방식으로 진행되어야 한다.**  
  
`예매하라 → 가격을 계산하라 → 할인 요금을 계산하라` 이 순서의 메시지를 응답할 수 있는 역할을 정하는 것이다.  
역할을 메시지를 응답하기 위한 여러 객체들을 포괄하는 **추상화** 라고 생각하면 좋다.  
